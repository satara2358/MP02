<div id="smoke-bkg" class="fixed top-0 -z-10 h-full w-full"></div>

<script>
  // Importa la librería Three.js
  import * as THREE from "three";

  // Obtiene el elemento con ID 'smoke-bkg' del documento
  const $bkg = document.getElementById("smoke-bkg");

  // Obtiene el ancho y alto de la ventana del navegador
  let w = window.innerWidth;
  let h = window.innerHeight;

  // Crea una nueva escena Three.js
  const scene = new THREE.Scene();

  // Crea una nueva cámara perspectiva con un campo de visión de 75 grados,
  // una relación de aspecto basada en el ancho y alto de la ventana, y un rango de visión entre 1 y 1000 unidades
  const camera = new THREE.PerspectiveCamera(75, w / h, 1, 1000);
  camera.position.z = 10; // Establece la posición de la cámara en el eje z
  scene.add(camera); // Agrega la cámara a la escena

  // Crea un renderizador WebGL
  const render = new THREE.WebGLRenderer();
  render.setSize(w, h); // Establece el tamaño del renderizador como el ancho y alto de la ventana
  render.setClearColor(0xffffff, 1); // Establece el color de fondo del renderizador como blanco
  $bkg?.appendChild(render.domElement); // Agrega el elemento del renderizador al elemento con ID 'smoke-bkg', si existe

  // Crea una luz direccional con color blanco y una intensidad del 50%
  const light = new THREE.DirectionalLight(0xffffff, 0.5);
  light.position.set(-1, 3, 1); // Establece la posición de la luz en la escena
  scene.add(light); // Agrega la luz a la escena

  // const geometry = new THREE.BoxGeometry(1, 1, 1);

  // const material = new THREE.MeshBasicMaterial({
  //   color: 0x0099ff,
  // });

  // const cube = new THREE.Mesh(geometry, material);
  // scene.add(cube);

  // Crea un arreglo para almacenar las partículas de humo como objetos Three.js Mesh
  const smokeParticules: THREE.Mesh[] = [];

  // Crea un cargador de texturas Three.js
  const loader = new THREE.TextureLoader();
  loader.crossOrigin = ""; // Establece la política de CORS para la carga de texturas

  // Carga la textura de humo desde la ruta especificada
  loader.load("/smoke.webp", (texture) => {
    // Crea geometría para las partículas de humo como planos
    const smokeGeometry = new THREE.PlaneGeometry(300, 300);

    // Crea un material Lambert para las partículas de humo con la textura cargada
    const smokeMaterial = new THREE.MeshLambertMaterial({
      map: texture, // Utiliza la textura cargada
      transparent: true, // Establece el material como transparente
    });

    // Define el número de partículas de humo
    const NUM_OF_PARTICLES = 300;

    // Itera para crear y posicionar cada partícula de humo
    for (let p = 0; p < NUM_OF_PARTICLES; p++) {
      // Crea una nueva malla (mesh) para representar una partícula de humo
      const particle = new THREE.Mesh(smokeGeometry, smokeMaterial);

      // Establece la posición de la partícula de humo dentro de un rango específico
      particle.position.set(
        Math.random() * 500 - 250, // Coordenada x aleatoria dentro de un rango
        Math.random() * 500 - 250, // Coordenada y aleatoria dentro de un rango
        Math.random() * 1000 - 100 // Coordenada z aleatoria dentro de un rango
      );

      // Establece una rotación aleatoria en el eje z para cada partícula de humo
      particle.rotation.z = Math.random() * 360;

      // Agrega la partícula de humo a la escena Three.js
      scene.add(particle);

      // Agrega la partícula de humo al arreglo para su posterior manipulación
      smokeParticules.push(particle);
    }
  });

  // Función para ajustar el tamaño del renderizador y la cámara al cambiar el tamaño de la ventana
  function resize() {
    // Actualiza las dimensiones de la ventana
    h = window.innerHeight;
    w = window.innerWidth;

    // Actualiza el aspecto de la cámara basado en el nuevo tamaño de la ventana
    camera.aspect = w / h;
    camera.updateProjectionMatrix();

    // Actualiza el tamaño del renderizador para que coincida con el nuevo tamaño de la ventana
    render.setSize(w, h);
  }

  // Función para animar las partículas de humo y renderizar la escena
  function animate() {
    // Solicita al navegador que llame a la función animate en el próximo ciclo de renderizado
    requestAnimationFrame(animate);

    // Itera sobre todas las partículas de humo y rota cada una en el eje z
    smokeParticules.forEach((particle) => {
      particle.rotation.z += 0.002; // Añade un pequeño incremento a la rotación de cada partícula
    });

    // Renderiza la escena con la cámara
    render.render(scene, camera);
  }

  // Inicia la animación
  animate();

  // Agrega un event listener para detectar cambios en el tamaño de la ventana y llamar a la función resize
  window.addEventListener("resize", resize);
</script>
